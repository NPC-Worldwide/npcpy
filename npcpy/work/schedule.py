"""Job scheduling — compile commands into self-contained scripts and manage
OS-level scheduling (crontab on Linux, launchd on macOS)."""

import os
import sys
import platform
import subprocess
import shutil

JOBS_DIR = os.path.expanduser('~/.npcsh/jobs')
LOGS_DIR = os.path.expanduser('~/.npcsh/logs')


def _npc_bin_path():
    """Full path to the ``npc`` binary in the current environment."""
    bin_dir = os.path.dirname(sys.executable)
    candidate = os.path.join(bin_dir, 'npc')
    if os.path.isfile(candidate):
        return candidate
    found = shutil.which('npc')
    return found or 'npc'


def _plist_path(job_name):
    return os.path.expanduser(
        '~/Library/LaunchAgents/com.npcsh.job.' + job_name + '.plist'
    )


def _cron_tag(job_name):
    return '# npcsh:' + job_name


# ── compile ──────────────────────────────────────────────────────────

def compile_job_script(command, job_name):
    """Turn *command* into a self-contained executable script.

    The command is a jinx name + args (e.g. ``nql query=... db=...``).
    The compiled script calls the ``npc`` binary with its full absolute
    path so it works in a minimal cron environment.

    Returns the path to the generated script (``~/.npcsh/jobs/<name>.sh``).
    """
    os.makedirs(JOBS_DIR, exist_ok=True)
    script_path = os.path.join(JOBS_DIR, job_name + '.sh')

    # Strip leading / if present — that's npcsh interactive shell syntax,
    # not relevant for compiled scripts.
    cmd = command.lstrip('/')

    npc = _npc_bin_path()
    lines = [
        '#!/bin/bash',
        '# Auto-generated by npcsh for job: ' + job_name,
        '# Do not edit — regenerated on every schedule toggle.',
        'set -euo pipefail',
        '',
        npc + ' ' + cmd,
        '',
    ]

    with open(script_path, 'w') as f:
        f.write('\n'.join(lines))
    os.chmod(script_path, 0o755)
    return script_path


# ── schedule / unschedule ────────────────────────────────────────────

def schedule_job(schedule, command, job_name):
    """Compile *command* and register it with the OS scheduler.

    Returns ``(success: bool, message: str)``.
    """
    os.makedirs(LOGS_DIR, exist_ok=True)
    script_path = compile_job_script(command, job_name)
    log_path = os.path.join(LOGS_DIR, job_name + '.log')

    if platform.system() == 'Darwin':
        return _schedule_launchd(script_path, schedule, job_name, log_path)
    return _schedule_crontab(script_path, schedule, job_name, log_path)


def unschedule_job(job_name):
    """Remove a scheduled job.  Returns ``(success, message)``."""
    if platform.system() == 'Darwin':
        return _unschedule_launchd(job_name)
    return _unschedule_crontab(job_name)


# ── list / status ────────────────────────────────────────────────────

def list_jobs():
    """Return a list of ``{'name': …, 'active': bool}`` for all npcsh jobs."""
    is_mac = platform.system() == 'Darwin'
    jobs = []
    if is_mac:
        agents = os.path.expanduser('~/Library/LaunchAgents/')
        if os.path.isdir(agents):
            for f in sorted(os.listdir(agents)):
                if f.startswith('com.npcsh.job.') and f.endswith('.plist'):
                    name = f.replace('com.npcsh.job.', '').replace('.plist', '')
                    r = subprocess.run(
                        ['launchctl', 'list', 'com.npcsh.job.' + name],
                        capture_output=True, text=True,
                    )
                    jobs.append({'name': name, 'active': r.returncode == 0})
    else:
        r = subprocess.run(['crontab', '-l'], capture_output=True, text=True)
        if r.returncode == 0:
            for line in r.stdout.splitlines():
                tag_pos = line.find('# npcsh:')
                if tag_pos >= 0:
                    name = line[tag_pos + 8:].strip()
                    jobs.append({'name': name, 'active': True})
    return jobs


def job_is_active(job_name):
    """Quick check whether *job_name* is currently scheduled."""
    if platform.system() == 'Darwin':
        return os.path.exists(_plist_path(job_name))
    r = subprocess.run(['crontab', '-l'], capture_output=True, text=True)
    if r.returncode == 0:
        return any(_cron_tag(job_name) in l for l in r.stdout.splitlines())
    return False


def job_status(job_name):
    """Detailed status dict for a job."""
    log_path = os.path.join(LOGS_DIR, job_name + '.log')
    info = {
        'name': job_name,
        'active': job_is_active(job_name),
        'log': log_path,
        'recent_log': [],
    }
    if os.path.exists(log_path):
        try:
            with open(log_path) as f:
                info['recent_log'] = f.readlines()[-10:]
        except OSError:
            pass
    return info


# ── macOS (launchd) internals ────────────────────────────────────────

def _schedule_launchd(script_path, schedule, job_name, log_path):
    ppath = _plist_path(job_name)
    os.makedirs(os.path.dirname(ppath), exist_ok=True)

    parts = schedule.split()
    plist = (
        '<?xml version="1.0" encoding="UTF-8"?>\n'
        '<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN"'
        ' "http://www.apple.com/DTDs/PropertyList-1.0.dtd">\n'
        '<plist version="1.0">\n<dict>\n'
        '  <key>Label</key>\n'
        '  <string>com.npcsh.job.' + job_name + '</string>\n'
        '  <key>ProgramArguments</key>\n  <array>\n'
        '    <string>' + script_path + '</string>\n'
        '  </array>\n'
    )

    if len(parts) == 5:
        plist += '  <key>StartCalendarInterval</key>\n  <dict>\n'
        field_map = [
            ('Minute', 0), ('Hour', 1), ('Day', 2),
            ('Month', 3), ('Weekday', 4),
        ]
        for key, idx in field_map:
            if parts[idx] != '*':
                plist += (
                    '    <key>' + key + '</key>\n'
                    '    <integer>' + parts[idx] + '</integer>\n'
                )
        plist += '  </dict>\n'

    plist += (
        '  <key>StandardOutPath</key>\n'
        '  <string>' + log_path + '</string>\n'
        '  <key>StandardErrorPath</key>\n'
        '  <string>' + log_path + '</string>\n'
        '</dict>\n</plist>\n'
    )

    with open(ppath, 'w') as f:
        f.write(plist)

    subprocess.run(['launchctl', 'load', ppath], capture_output=True)
    return True, 'Scheduled "' + job_name + '": ' + schedule


def _unschedule_launchd(job_name):
    ppath = _plist_path(job_name)
    if os.path.exists(ppath):
        subprocess.run(['launchctl', 'unload', ppath], capture_output=True)
        os.remove(ppath)
        return True, 'Removed "' + job_name + '"'
    return False, 'Job "' + job_name + '" not found.'


# ── Linux (crontab) internals ────────────────────────────────────────

def _schedule_crontab(script_path, schedule, job_name, log_path):
    r = subprocess.run(['crontab', '-l'], capture_output=True, text=True)
    existing = r.stdout if r.returncode == 0 else ''
    entry = (
        schedule + ' ' + script_path
        + ' >> ' + log_path + ' 2>&1 '
        + _cron_tag(job_name)
    )
    new_crontab = existing.rstrip('\n') + '\n' + entry + '\n'
    p = subprocess.run(
        ['crontab', '-'], input=new_crontab,
        capture_output=True, text=True,
    )
    if p.returncode == 0:
        return True, 'Scheduled "' + job_name + '": ' + schedule
    return False, 'Failed: ' + p.stderr


def _unschedule_crontab(job_name):
    r = subprocess.run(['crontab', '-l'], capture_output=True, text=True)
    if r.returncode == 0:
        tag = _cron_tag(job_name)
        lines = [l for l in r.stdout.splitlines() if tag not in l]
        p = subprocess.run(
            ['crontab', '-'], input='\n'.join(lines) + '\n',
            capture_output=True, text=True,
        )
        if p.returncode == 0:
            return True, 'Removed "' + job_name + '"'
        return False, 'Failed: ' + p.stderr
    return False, 'No crontab found.'
